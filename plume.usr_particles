c-----------------------------------------------------------------------
c-----------------------------------------------------------------------

c-----------------------------------------------------------------------
c This function can be used to specify customized or solution dependent material properties.
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c      e = gllel(eg)

      udiff =0
      utrans=0

      return
      end

c-----------------------------------------------------------------------
c This function sets the source term (which will be subsequently be multiplied by the density) for the momentum equation.
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,iel)
      include 'SIZE'
      include 'TSTEP'
c     include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg

      Fr = 1.0

      ffx = 0.0
      ffy = (1/Fr)*temp
      ffz = 0.0

      return
      end

c-----------------------------------------------------------------------
c This function sets the source term for the scalar equation.
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,iel)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

      qvol   = 0.0
      source = 0.0

      return
      end

c-----------------------------------------------------------------------
c This is a general purpose function that is executed before the time stepper and after every time step.
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      common /mychk/ vxo(lx1*ly1*lz1*lelt),vyo(lx1*ly1*lz1*lelt)
      common /rparts/ pts(ldim,lpart),vel(ldim,2:3,lpart)
      common /iparts/ npart,partid(lpart)
      integer partid

      ifto = .true.
c      if (istep.eq.0.or.mod(istep,iostep).eq.0) 
c     $   call lambda2(t)   ! Put lambda2 into temperature field


c     NOTE:  The following outpost call coordinates the .f0000 numbering
c            with the particle file numbering.
c
c            This coordination is important when syncing frames for a movie.

      ipstep = iostep ! Particle output coordinated with iostep
      ipstep = iostep/4

      ifxyo = .true.
      if (istep.gt.iostep) ifxyo = .false.
      if (istep.eq.0) call outpost(vx,vy,vz,pr,t,'   ') ! Part. coordination
      call my_particle_generator(ipstep)                ! Particle injection

      n=nx1*ny1*nz1*nelt
      umax = glamax(vx,n)
      vmax = glamax(vy,n)
      wmin = glmin(vz,n)
      wmax = glmax(vz,n)
      wmax = glmax(vz,n)
      tmax = glmax(t ,n)

      dmax = 0
      if (istep.gt.1) then
         do i=1,n
            diff = (vxo(i)-vx(i,1,1,1))**2 + (vxo(i)-vx(i,1,1,1))**2
            dmax = max(dmax,diff)
         enddo
         dmax = glmax(dmax,1)
         if (dmax.gt.0) dmax = sqrt(dmax)/dt
      endif
      call copy(vxo,vx,n)
      call copy(vyo,vy,n)

c      if (nid.eq.0) write(6,1) istep,time,umax,vmax,wmin,wmax
c    1 format(i9,1p5e12.4,' wmax')

      if (nid.eq.0.and.mod(istep,10).eq.0)
     $     write(6,1) istep,time,dmax,vmax,tmax
    1 format(i9,1p4e13.5,' tmax')

      return
      end

c-----------------------------------------------------------------------
c This function sets boundary conditions. Note, this function is only called for special boundary condition types and only for points on the boundary surface.
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /cmygeom/ rad_mid

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      gridSize = 100
      centre = gridSize/2

      maxtemp = 1
      coeff = 1

      if(y.lt.gridSize/2)then
	temp = maxtemp*EXP(-(0.5*coeff*(x - centre)**2))
      endif

      return
      end

c-----------------------------------------------------------------------
c This function sets initial conditions.
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      gridSize = 100
      centre = gridSize/2

      maxtemp = 1
      coeff = 1
      stand_dev_y = 0.01

      temp_prox = maxtemp*EXP(-(0.5*coeff*(x - centre)**2))
      temp = temp_prox*EXP(-(y**2)/(2*stand_dev_y**2))

      return
      end

c-----------------------------------------------------------------------
c This function can be used to modify the element vertices.
c-----------------------------------------------------------------------
      subroutine usrdat

      return
      end

c-----------------------------------------------------------------------
c This function can be used to modify the spectral element mesh.
c-----------------------------------------------------------------------
      subroutine usrdat2

      return
      end

c-----------------------------------------------------------------------
c This function can be used to initialize case/user specific data.
c-----------------------------------------------------------------------
      subroutine usrdat3

      return
      end

c-----------------------------------------------------------------------
c The following functions implement particle behaviour and are called by user_chk.
c-----------------------------------------------------------------------
      subroutine interp_v(uvw,xyz,n)
c
c     evaluate velocity for list of points xyz
c
      include 'SIZE'
      include 'TOTAL'

      real uvw(ldim,n),xyz(ldim,n)

      parameter(nmax=lpart,nfldmx=ldim) 

      common /rwk_intp/ 
     $       fwrk(lx1*ly1*lz1*lelt,nfldmx),
     $       rwk(nmax,ldim+1),
     $       fpts(ldim*nmax),
     $       pts(ldim*nmax)
      common /iwk_intp/ 
     $       iwk(nmax,3)


      integer icalld,e
      save    icalld
      data    icalld /0/

      nxyz  = nx1*ny1*nz1
      ntot  = nxyz*nelt

      if (n.gt.nmax) call exitti ('n > nmax in interp_v!$',n)
      
      if (nelgt.ne.nelgv) call exitti
     $   ('nelgt.ne.nelgv not yet supported in interp_v!$',nelgv)

      do i=1,n				! ? not moving -> save?
         pts(i)     = xyz(1,i)
         pts(i + n) = xyz(2,i)
         if (if3d) pts(i + n*2) = xyz(3,i)
      enddo

      if (icalld.eq.0) then		! interpolation setup
        icalld = 1
        tolin  = 1.e-8
        call intp_setup(tolin)
      endif

      ! pack working array
      call opcopy(fwrk(1,1),fwrk(1,2),fwrk(1,3),vx,vy,vz)

      ! interpolate
      call intp_do(fpts,fwrk,ndim,
     $             pts(1),pts(1+n),pts(2*n+1),n,
     $             iwk,rwk,nmax,.true.)

c HERE WE APPLY A SETTLING VELOCITY

      do i=1,n
         uvw(1,i) = fpts(i)
         uvw(2,i) = fpts(i + n) - 0.1
         if(if3d) uvw(3,i) = fpts(i + n*2)
      enddo

      return
      end

c-----------------------------------------------------------------------
      subroutine particle_advect_std(x,vh,partv,npart)

c     Lagrangian particle advection

      include 'SIZE'
      include 'TOTAL'

      real x(ldim,lpart),vh(ldim,2:3,lpart),partv(lpart)
      common /scruz/ u1(ldim,lpart)

      common /padvc/ xmx(3,0:2)

      if (istep.eq.0) then      ! AB1
         call rzero(vh,3*ndim*npart) 
         c1 = 1.
         c2 = 0.
         c3 = 0.
      elseif (istep.eq.1) then  ! AB2
         c1 = 3
         c2 = -1.
         c3 = 0
         c1 = c1/2.
         c2 = c2/2.
      else                    ! AB3
         c1 = 23.
         c2 = -16.
         c3 = 5.
         c1 = c1/12.
         c2 = c2/12.
         c3 = c3/12
      endif


      call interp_v(u1,x,npart) 

      do i=1,npart
      do k=1,ndim
C     Update particle position and history
           x(k,i) = x(k,i) 
     $              + dt*(c1*u1(k,i) + c2*vh(k,2,i) + c3*vh(k,3,i))
C     Update particle and fluid velocity history
           vh(k,3,i) = vh(k,2,i)
           vh(k,2,i) = u1(k,i)
      enddo
      enddo

      return
      end

c----------------------------------------------------------------------
      subroutine particle_out (x,partid,partv,npart,ipstep)
      include 'SIZE'
      include 'TOTAL'
      
      real x(ldim,lpart),partv(lpart)
      integer partid(lpart)

      common /scrns/ x_tmp(ldim+1,lpart),work(ldim+1,lpart)

      character*128 fname

      integer icalld
      save    icalld
      data    icalld  /0/

      if (mod(istep,ipstep).ne.0) return

      icalld = icalld+1
      if (nid.eq.0) then
        write(fname,1) icalld
 1      format('part',i5.5,'.3D')
        open(unit=72,file=fname)
      endif

      min_points = iglmin(partid,npart)
      max_points = iglmax(partid,npart)
      n_active   = max_points - min_points + 1
      npass = n_active / lpart
      if (n_active.gt.npass*lpart) npass = npass+1
      ilast=min_points-1

      do ipass=1,npass

        mpart = min(lpart,max_points-ilast)
        i0    = ilast
        i1    = i0 + mpart
        ilast = i1

        call rzero(x_tmp,(ldim+1)*lpart)
        do ii=1,npart
          if (i0.lt.partid(ii).and.partid(ii).le.i1) then
            i = partid(ii)-i0
            call copy(x_tmp(1,i),x(1,ii),ldim)  ! Coordinates
            x_tmp(ldim+1,i) = partv(ii)         ! Store value here
          endif
        enddo

        call gop(x_tmp,work,'+  ',(ldim+1)*lpart)
        if (nid.eq.0) write(72,2)((x_tmp(k,i),k=1,ldim+1),i=1,mpart)
 2      format(1p3e17.9)
        
      enddo

      if (nid.eq.0) close(72)

      return
      end

c-----------------------------------------------------------------------
      subroutine my_particle_generator(ipstep) ! Particle injection
      include 'SIZE'
      include 'TOTAL'
      include 'mpif.h'

      common /rparts/ pts(ldim,lpart),vel(ldim,2:3,lpart),partv(lpart)
      common /iparts/ npart,partid(lpart)
      integer partid

      real ptime           ! Time the particle motion
      save ptime
      data ptime  /0./

      ptime0 = dnekclock_sync()

c The following if statement ensures that particle injection only occurs on the first time-step.
      if (istep.eq.0) then
        call particle_init       (pts,partid,partv,npart,ipstep)
      endif

      call particle_advect_std (pts,vel,partv,npart)
      call particle_out        (pts,partid,partv,npart,ipstep)

      ptime1 = dnekclock_sync() ! Track computational cost of particles

      dptime = (ptime1-ptime0)
      ptime  = ptime + dptime

      if (mod(istep,ipstep).eq.0) then
         npmin = iglmin(npart,1)
         npmax = iglmax(npart,1)
         nptot = iglsum(npart,1)
         npmav = nptot/np
         ptpp  = dptime / nptot  ! particle-time per point
         if (nid.eq.0) write(6,1)
     $      istep,npmin,npmav,npmax,nptot,ptpp,dptime,ptime,time
    1       format(4i7,i9,1p4e15.7,' ptime')
      endif
      
      return
      end

c-----------------------------------------------------------------------
      subroutine particle_init(x,partid,partv,npart,ipstep)
c
c     This version does continuous injection and overwrites old entries
c
      include 'SIZE'
      include 'TOTAL'

      real x(ldim,lpart),partv(lpart)
      integer partid(lpart)

      integer lcount,icount
      save    lcount,icount
      data    lcount,icount /0,0/

      if (mod(istep,ipstep).ne.0) return

      llpart = lpart

      dx = 0.05
      dy = .025
      ds = (1-dy)/100

      k0 = 0
      k  = icount       ! icount = total # particles emitted
      l  = lcount       ! Index into local particle array

      xp = 49.9
      zp = 0
      yp = 1

      if (mod(k,np).eq.nid) then ! Inject particle _only_ on this processor
            l=l+1  ! local count
            if (l.gt.llpart) l=1 ! Retire old particles by overwriting their data
            x(1,l) = xp
            x(2,l) = yp
            x(3,l) = zp
            partid(l) = k+1
            partv(l) = iline ! color by line
      endif
            
      k = k+1     ! Total count

      k0= k0+1    ! Count for this release (for coloring only)

      icount = k
      lcount = l
      npart  = max(npart,lcount)

      return
      end

c-----------------------------------------------------------------------
